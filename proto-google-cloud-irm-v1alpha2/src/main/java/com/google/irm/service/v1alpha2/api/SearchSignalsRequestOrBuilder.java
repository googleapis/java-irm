/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/irm/v1alpha2/incidents_service.proto

package com.google.irm.service.v1alpha2.api;

public interface SearchSignalsRequestOrBuilder
    extends
    // @@protoc_insertion_point(interface_extends:google.cloud.irm.v1alpha2.SearchSignalsRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   *
   *
   * <pre>
   * The resource name of the hosting Stackdriver project which requested
   * incidents belong to.
   * </pre>
   *
   * <code>string parent = 1;</code>
   *
   * @return The parent.
   */
  java.lang.String getParent();
  /**
   *
   *
   * <pre>
   * The resource name of the hosting Stackdriver project which requested
   * incidents belong to.
   * </pre>
   *
   * <code>string parent = 1;</code>
   *
   * @return The bytes for parent.
   */
  com.google.protobuf.ByteString getParentBytes();

  /**
   *
   *
   * <pre>
   * An expression that defines which signals to return.
   * Search atoms can be used to match certain specific fields.  Otherwise,
   * plain text will match text fields in the signal.
   * Search atoms:
   * * `start` - (timestamp) The time the signal was created.
   * * `title` - The title of the signal.
   * * `signal_state` - `open` or `closed`. State of the signal.
   *   (e.g., `signal_state:open`)
   * Timestamp formats:
   * * yyyy-MM-dd - an absolute date, treated as a calendar-day-wide window.
   *   In other words, the "&lt;" operator will match dates before that date, the
   *   "&gt;" operator will match dates after that date, and the ":" operator will
   *   match the entire day.
   * * yyyy-MM-ddTHH:mm - Same as above, but with minute resolution.
   * * yyyy-MM-ddTHH:mm:ss - Same as above, but with second resolution.
   * * Nd (e.g. 7d) - a relative number of days ago, treated as a moment in time
   *   (as opposed to a day-wide span) a multiple of 24 hours ago (as opposed to
   *   calendar days).  In the case of daylight savings time, it will apply the
   *   current timezone to both ends of the range.  Note that exact matching
   *   (e.g. `start:7d`) is unlikely to be useful because that would only match
   *   signals created precisely at a particular instant in time.
   * The absolute timestamp formats (everything starting with a year) can
   * optionally be followed with a UTC offset in +/-hh:mm format.  Also, the 'T'
   * separating dates and times can optionally be replaced with a space. Note
   * that any timestamp containing a space or colon will need to be quoted.
   * Examples:
   * * `foo` - matches signals containing the word "foo"
   * * `"foo bar"` - matches signals containing the phrase "foo bar"
   * * `foo bar` or `foo AND bar` - matches signals containing the words
   *   "foo" and "bar"
   * * `foo -bar` or `foo AND NOT bar` - matches signals containing the
   *   word
   *   "foo" but not the word "bar"
   * * `foo OR bar` - matches signals containing the word "foo" or the
   *   word "bar"
   * * `start&gt;2018-11-28` - matches signals which started after November
   *   11, 2018.
   * * `start&lt;=2018-11-28` - matches signals which started on or before
   *   November 11, 2018.
   * * `start:2018-11-28` - matches signals which started on November 11,
   *   2018.
   * * `start&gt;"2018-11-28 01:02:03+04:00"` - matches signals which started
   *   after November 11, 2018 at 1:02:03 AM according to the UTC+04 time
   *   zone.
   * * `start&gt;7d` - matches signals which started after the point in time
   *   7*24 hours ago
   * * `start&gt;180d` - similar to 7d, but likely to cross the daylight savings
   *   time boundary, so the end time will be 1 hour different from "now."
   * * `foo AND start&gt;90d AND stage&lt;resolved` - unresolved signals from
   *   the past 90 days containing the word "foo"
   * </pre>
   *
   * <code>string query = 2;</code>
   *
   * @return The query.
   */
  java.lang.String getQuery();
  /**
   *
   *
   * <pre>
   * An expression that defines which signals to return.
   * Search atoms can be used to match certain specific fields.  Otherwise,
   * plain text will match text fields in the signal.
   * Search atoms:
   * * `start` - (timestamp) The time the signal was created.
   * * `title` - The title of the signal.
   * * `signal_state` - `open` or `closed`. State of the signal.
   *   (e.g., `signal_state:open`)
   * Timestamp formats:
   * * yyyy-MM-dd - an absolute date, treated as a calendar-day-wide window.
   *   In other words, the "&lt;" operator will match dates before that date, the
   *   "&gt;" operator will match dates after that date, and the ":" operator will
   *   match the entire day.
   * * yyyy-MM-ddTHH:mm - Same as above, but with minute resolution.
   * * yyyy-MM-ddTHH:mm:ss - Same as above, but with second resolution.
   * * Nd (e.g. 7d) - a relative number of days ago, treated as a moment in time
   *   (as opposed to a day-wide span) a multiple of 24 hours ago (as opposed to
   *   calendar days).  In the case of daylight savings time, it will apply the
   *   current timezone to both ends of the range.  Note that exact matching
   *   (e.g. `start:7d`) is unlikely to be useful because that would only match
   *   signals created precisely at a particular instant in time.
   * The absolute timestamp formats (everything starting with a year) can
   * optionally be followed with a UTC offset in +/-hh:mm format.  Also, the 'T'
   * separating dates and times can optionally be replaced with a space. Note
   * that any timestamp containing a space or colon will need to be quoted.
   * Examples:
   * * `foo` - matches signals containing the word "foo"
   * * `"foo bar"` - matches signals containing the phrase "foo bar"
   * * `foo bar` or `foo AND bar` - matches signals containing the words
   *   "foo" and "bar"
   * * `foo -bar` or `foo AND NOT bar` - matches signals containing the
   *   word
   *   "foo" but not the word "bar"
   * * `foo OR bar` - matches signals containing the word "foo" or the
   *   word "bar"
   * * `start&gt;2018-11-28` - matches signals which started after November
   *   11, 2018.
   * * `start&lt;=2018-11-28` - matches signals which started on or before
   *   November 11, 2018.
   * * `start:2018-11-28` - matches signals which started on November 11,
   *   2018.
   * * `start&gt;"2018-11-28 01:02:03+04:00"` - matches signals which started
   *   after November 11, 2018 at 1:02:03 AM according to the UTC+04 time
   *   zone.
   * * `start&gt;7d` - matches signals which started after the point in time
   *   7*24 hours ago
   * * `start&gt;180d` - similar to 7d, but likely to cross the daylight savings
   *   time boundary, so the end time will be 1 hour different from "now."
   * * `foo AND start&gt;90d AND stage&lt;resolved` - unresolved signals from
   *   the past 90 days containing the word "foo"
   * </pre>
   *
   * <code>string query = 2;</code>
   *
   * @return The bytes for query.
   */
  com.google.protobuf.ByteString getQueryBytes();

  /**
   *
   *
   * <pre>
   * Maximum number of `signals` to return in the response.
   * </pre>
   *
   * <code>int32 page_size = 3;</code>
   *
   * @return The pageSize.
   */
  int getPageSize();

  /**
   *
   *
   * <pre>
   * Page token from an earlier query, as returned in `next_page_token`. All
   * field values except for page_size and page_token should be the same as the
   * original query (may return an error or unexpected data otherwise).
   * </pre>
   *
   * <code>string page_token = 4;</code>
   *
   * @return The pageToken.
   */
  java.lang.String getPageToken();
  /**
   *
   *
   * <pre>
   * Page token from an earlier query, as returned in `next_page_token`. All
   * field values except for page_size and page_token should be the same as the
   * original query (may return an error or unexpected data otherwise).
   * </pre>
   *
   * <code>string page_token = 4;</code>
   *
   * @return The bytes for pageToken.
   */
  com.google.protobuf.ByteString getPageTokenBytes();
}
